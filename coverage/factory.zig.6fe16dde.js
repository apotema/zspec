var data = {lines:[
{"lineNum":"    1","line":"//! ZSpec Factory - FactoryBot-like test data generation for Zig"},
{"lineNum":"    2","line":"//!"},
{"lineNum":"    3","line":"//! Provides:"},
{"lineNum":"    4","line":"//! - Factory.define() - Define factories with default values"},
{"lineNum":"    5","line":"//! - Factory.sequence() - Auto-incrementing values"},
{"lineNum":"    6","line":"//! - Factory.sequenceFmt() - Formatted sequence strings"},
{"lineNum":"    7","line":"//! - Factory.lazy() - Computed values"},
{"lineNum":"    8","line":"//! - Factory.assoc() - Nested factory associations"},
{"lineNum":"    9","line":"//! - .trait() - Predefined variants"},
{"lineNum":"   10","line":"//! - .build() / .buildPtr() - Create instances"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"const std = @import(\"std\");"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"/// Global sequence counters - reset with resetSequences()"},
{"lineNum":"   15","line":"/// Using a simple array-based approach for simplicity and to avoid hashmap issues"},
{"lineNum":"   16","line":"const MAX_SEQUENCES = 256;"},
{"lineNum":"   17","line":"var sequence_values: [MAX_SEQUENCES]u64 = [_]u64{0} ** MAX_SEQUENCES;"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"/// Reset all sequence counters to 0"},
{"lineNum":"   20","line":"pub fn resetSequences() void {","class":"lineCov","hits":"1","order":"91","possible_hits":"1",},
{"lineNum":"   21","line":"    sequence_values = [_]u64{0} ** MAX_SEQUENCES;","class":"lineCov","hits":"2","order":"92","possible_hits":"2",},
{"lineNum":"   22","line":"}"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":"fn getNextSequence(id: usize) u64 {","class":"lineCov","hits":"1","order":"97","possible_hits":"1",},
{"lineNum":"   25","line":"    const index = id % MAX_SEQUENCES;","class":"lineCov","hits":"1","order":"98","possible_hits":"1",},
{"lineNum":"   26","line":"    sequence_values[index] += 1;","class":"lineCov","hits":"2","order":"99","possible_hits":"2",},
{"lineNum":"   27","line":"    return sequence_values[index];","class":"lineCov","hits":"3","order":"100","possible_hits":"3",},
{"lineNum":"   28","line":"}"},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"/// Marker type for sequence fields"},
{"lineNum":"   31","line":"pub fn SequenceType(comptime T: type) type {"},
{"lineNum":"   32","line":"    return struct {"},
{"lineNum":"   33","line":"        pub const sequence_type = T;"},
{"lineNum":"   34","line":"        pub const is_sequence = true;"},
{"lineNum":"   35","line":"    };"},
{"lineNum":"   36","line":"}"},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"/// Marker type for formatted sequence fields"},
{"lineNum":"   39","line":"pub fn SequenceFmtType(comptime fmt: []const u8) type {"},
{"lineNum":"   40","line":"    return struct {"},
{"lineNum":"   41","line":"        pub const format_string = fmt;"},
{"lineNum":"   42","line":"        pub const is_sequence_fmt = true;"},
{"lineNum":"   43","line":"    };"},
{"lineNum":"   44","line":"}"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"/// Marker type for lazy/computed fields"},
{"lineNum":"   47","line":"pub fn Lazy(comptime T: type, comptime func: fn () T) type {"},
{"lineNum":"   48","line":"    return struct {"},
{"lineNum":"   49","line":"        pub const lazy_type = T;"},
{"lineNum":"   50","line":"        pub const compute = func;"},
{"lineNum":"   51","line":"        pub const is_lazy = true;"},
{"lineNum":"   52","line":"    };"},
{"lineNum":"   53","line":"}"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"/// Marker type for lazy fields with allocator"},
{"lineNum":"   56","line":"pub fn LazyAlloc(comptime T: type, comptime func: fn (std.mem.Allocator) T) type {"},
{"lineNum":"   57","line":"    return struct {"},
{"lineNum":"   58","line":"        pub const lazy_type = T;"},
{"lineNum":"   59","line":"        pub const computeAlloc = func;"},
{"lineNum":"   60","line":"        pub const is_lazy_alloc = true;"},
{"lineNum":"   61","line":"    };"},
{"lineNum":"   62","line":"}"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"/// Marker type for associations"},
{"lineNum":"   65","line":"pub fn Assoc(comptime FactoryType: type) type {"},
{"lineNum":"   66","line":"    return struct {"},
{"lineNum":"   67","line":"        pub const factory = FactoryType;"},
{"lineNum":"   68","line":"        pub const is_assoc = true;"},
{"lineNum":"   69","line":"    };"},
{"lineNum":"   70","line":"}"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"/// Create a sequence marker for auto-incrementing numeric values."},
{"lineNum":"   73","line":"pub fn sequence(comptime T: type) SequenceType(T) {"},
{"lineNum":"   74","line":"    return .{};"},
{"lineNum":"   75","line":"}"},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"/// Create a formatted sequence marker for strings like \"user{d}@example.com\"."},
{"lineNum":"   78","line":"pub fn sequenceFmt(comptime fmt: []const u8) SequenceFmtType(fmt) {"},
{"lineNum":"   79","line":"    return .{};"},
{"lineNum":"   80","line":"}"},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"/// Create a lazy marker for computed values"},
{"lineNum":"   83","line":"pub fn lazy(comptime func: anytype) Lazy(@typeInfo(@TypeOf(func)).@\"fn\".return_type.?, func) {"},
{"lineNum":"   84","line":"    return .{};"},
{"lineNum":"   85","line":"}"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"/// Create a lazy marker for computed values that need an allocator"},
{"lineNum":"   88","line":"pub fn lazyAlloc(comptime func: anytype) LazyAlloc(@typeInfo(@TypeOf(func)).@\"fn\".return_type.?, func) {"},
{"lineNum":"   89","line":"    return .{};"},
{"lineNum":"   90","line":"}"},
{"lineNum":"   91","line":""},
{"lineNum":"   92","line":"/// Create an association marker for nested factories"},
{"lineNum":"   93","line":"pub fn assoc(comptime FactoryType: type) Assoc(FactoryType) {"},
{"lineNum":"   94","line":"    return .{};"},
{"lineNum":"   95","line":"}"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"/// Define a factory for a given type with default values"},
{"lineNum":"   98","line":"pub fn define(comptime T: type, comptime defaults: anytype) type {"},
{"lineNum":"   99","line":"    return FactoryImpl(T, defaults, 0);"},
{"lineNum":"  100","line":"}"},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"/// Define a factory from comptime data (e.g., imported from a .zon file)"},
{"lineNum":"  103","line":"///"},
{"lineNum":"  104","line":"/// This is a convenience wrapper around `define()` that validates unknown fields"},
{"lineNum":"  105","line":"/// and makes the intent clear when loading factory definitions from external .zon files."},
{"lineNum":"  106","line":"///"},
{"lineNum":"  107","line":"/// Unlike `define()`, this function will produce a compile error if the .zon data"},
{"lineNum":"  108","line":"/// contains fields that don\'t exist in the target type T, catching typos early."},
{"lineNum":"  109","line":"///"},
{"lineNum":"  110","line":"/// Example usage:"},
{"lineNum":"  111","line":"/// ```zig"},
{"lineNum":"  112","line":"/// const factory_defs = @import(\"test_factories.zon\");"},
{"lineNum":"  113","line":"/// pub const UserFactory = Factory.defineFrom(User, factory_defs.user);"},
{"lineNum":"  114","line":"/// pub const ProductFactory = Factory.defineFrom(Product, factory_defs.product);"},
{"lineNum":"  115","line":"/// ```"},
{"lineNum":"  116","line":"///"},
{"lineNum":"  117","line":"/// The .zon file would contain:"},
{"lineNum":"  118","line":"/// ```zig"},
{"lineNum":"  119","line":"/// .{"},
{"lineNum":"  120","line":"///     .user = .{ .name = \"John\", .email = \"john@example.com\", .age = 25 },"},
{"lineNum":"  121","line":"///     .product = .{ .name = \"Widget\", .price = 9.99, .in_stock = true },"},
{"lineNum":"  122","line":"/// }"},
{"lineNum":"  123","line":"/// ```"},
{"lineNum":"  124","line":"///"},
{"lineNum":"  125","line":"/// Note: .zon files contain static comptime data only. For dynamic features like"},
{"lineNum":"  126","line":"/// sequences or lazy values, use `define()` directly or apply them via traits."},
{"lineNum":"  127","line":"pub fn defineFrom(comptime T: type, comptime zon_data: anytype) type {"},
{"lineNum":"  128","line":"    // Validate that all fields in zon_data exist in T (catches typos in .zon files)"},
{"lineNum":"  129","line":"    validateZonFields(T, zon_data);"},
{"lineNum":"  130","line":"    return define(T, zon_data);"},
{"lineNum":"  131","line":"}"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"/// Validate that all fields in zon_data exist in the target type T (recursive for nested structs)."},
{"lineNum":"  134","line":"/// This catches typos in .zon files at compile time."},
{"lineNum":"  135","line":"fn validateZonFields(comptime T: type, comptime zon_data: anytype) void {"},
{"lineNum":"  136","line":"    const ZonType = @TypeOf(zon_data);"},
{"lineNum":"  137","line":"    const zon_fields = std.meta.fields(ZonType);"},
{"lineNum":"  138","line":"    const target_fields = std.meta.fields(T);"},
{"lineNum":"  139","line":""},
{"lineNum":"  140","line":"    inline for (zon_fields) |zon_field| {"},
{"lineNum":"  141","line":"        if (!@hasField(T, zon_field.name)) {"},
{"lineNum":"  142","line":"            @compileError(\"Unknown field \'\" ++ zon_field.name ++ \"\' in .zon data. \" ++"},
{"lineNum":"  143","line":"                \"Type \'\" ++ @typeName(T) ++ \"\' has no such field. \" ++"},
{"lineNum":"  144","line":"                \"Check for typos in your .zon file.\");"},
{"lineNum":"  145","line":"        }"},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"        // Find the target field type and recursively validate nested structs"},
{"lineNum":"  148","line":"        inline for (target_fields) |target_field| {"},
{"lineNum":"  149","line":"            if (comptime std.mem.eql(u8, target_field.name, zon_field.name)) {"},
{"lineNum":"  150","line":"                const zon_field_value = @field(zon_data, zon_field.name);"},
{"lineNum":"  151","line":"                const ZonFieldType = @TypeOf(zon_field_value);"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"                // If both are structs, recursively validate"},
{"lineNum":"  154","line":"                if (@typeInfo(target_field.type) == .@\"struct\" and @typeInfo(ZonFieldType) == .@\"struct\") {"},
{"lineNum":"  155","line":"                    validateZonFields(target_field.type, zon_field_value);"},
{"lineNum":"  156","line":"                }"},
{"lineNum":"  157","line":"                // If target is union and source is struct, validate the union payload"},
{"lineNum":"  158","line":"                else if (@typeInfo(target_field.type) == .@\"union\" and @typeInfo(ZonFieldType) == .@\"struct\") {"},
{"lineNum":"  159","line":"                    validateUnionPayload(target_field.type, zon_field_value);"},
{"lineNum":"  160","line":"                }"},
{"lineNum":"  161","line":"                break;"},
{"lineNum":"  162","line":"            }"},
{"lineNum":"  163","line":"        }"},
{"lineNum":"  164","line":"    }"},
{"lineNum":"  165","line":"}"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"/// Validate that a union payload struct has valid fields"},
{"lineNum":"  168","line":"fn validateUnionPayload(comptime UnionType: type, comptime zon_data: anytype) void {"},
{"lineNum":"  169","line":"    const ZonType = @TypeOf(zon_data);"},
{"lineNum":"  170","line":"    const zon_fields = std.meta.fields(ZonType);"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"    if (zon_fields.len != 1) {"},
{"lineNum":"  173","line":"        @compileError(\"Union value must have exactly one field matching a union tag\");"},
{"lineNum":"  174","line":"    }"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"    const tag_name = zon_fields[0].name;"},
{"lineNum":"  177","line":"    const union_info = @typeInfo(UnionType).@\"union\";"},
{"lineNum":"  178","line":""},
{"lineNum":"  179","line":"    // Find the union field and validate its payload"},
{"lineNum":"  180","line":"    inline for (union_info.fields) |union_field| {"},
{"lineNum":"  181","line":"        if (comptime std.mem.eql(u8, union_field.name, tag_name)) {"},
{"lineNum":"  182","line":"            const payload_value = @field(zon_data, tag_name);"},
{"lineNum":"  183","line":"            const PayloadZonType = @TypeOf(payload_value);"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"            // If payload is a struct, validate its fields"},
{"lineNum":"  186","line":"            if (@typeInfo(union_field.type) == .@\"struct\" and @typeInfo(PayloadZonType) == .@\"struct\") {"},
{"lineNum":"  187","line":"                validateZonFields(union_field.type, payload_value);"},
{"lineNum":"  188","line":"            }"},
{"lineNum":"  189","line":"            return;"},
{"lineNum":"  190","line":"        }"},
{"lineNum":"  191","line":"    }"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"    @compileError(\"Unknown union tag \'\" ++ tag_name ++ \"\' in .zon data. \" ++"},
{"lineNum":"  194","line":"        \"Union \'\" ++ @typeName(UnionType) ++ \"\' has no such variant.\");"},
{"lineNum":"  195","line":"}"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"/// Coerce an anonymous struct to a union type"},
{"lineNum":"  198","line":"/// e.g., .{ .circle = .{ .radius = 10 } } -> Shape{ .circle = ... }"},
{"lineNum":"  199","line":"fn coerceToUnion(comptime UnionType: type, default_value: anytype) UnionType {"},
{"lineNum":"  200","line":"    const DefaultType = @TypeOf(default_value);"},
{"lineNum":"  201","line":"    const default_fields = std.meta.fields(DefaultType);"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"    // Anonymous struct must have exactly one field"},
{"lineNum":"  204","line":"    if (default_fields.len != 1) {"},
{"lineNum":"  205","line":"        @compileError(\"Union default value must be a struct with exactly one field matching a union tag\");"},
{"lineNum":"  206","line":"    }"},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"    const tag_name = default_fields[0].name;"},
{"lineNum":"  209","line":"    const union_info = @typeInfo(UnionType).@\"union\";"},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"    // Find the expected payload type for this tag"},
{"lineNum":"  212","line":"    inline for (union_info.fields) |union_field| {"},
{"lineNum":"  213","line":"        if (comptime std.mem.eql(u8, union_field.name, tag_name)) {"},
{"lineNum":"  214","line":"            const PayloadType = union_field.type;"},
{"lineNum":"  215","line":"            const source_payload = @field(default_value, tag_name);"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"            // Build the correctly-typed payload"},
{"lineNum":"  218","line":"            const typed_payload = buildTypedPayload(PayloadType, source_payload);"},
{"lineNum":"  219","line":"            return @unionInit(UnionType, tag_name, typed_payload);"},
{"lineNum":"  220","line":"        }"},
{"lineNum":"  221","line":"    }"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"    @compileError(\"No union field named \'\" ++ tag_name ++ \"\' in union type\");"},
{"lineNum":"  224","line":"}"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"/// Build a nested struct from an anonymous source struct (for pointer-to-struct overrides)"},
{"lineNum":"  227","line":"fn buildNestedStruct(comptime TargetType: type, source: anytype) TargetType {"},
{"lineNum":"  228","line":"    var result: TargetType = undefined;"},
{"lineNum":"  229","line":"    const SourceType = @TypeOf(source);"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":"    inline for (std.meta.fields(TargetType)) |field| {"},
{"lineNum":"  232","line":"        if (@hasField(SourceType, field.name)) {"},
{"lineNum":"  233","line":"            @field(result, field.name) = @field(source, field.name);"},
{"lineNum":"  234","line":"        } else if (field.default_value_ptr) |default_ptr| {"},
{"lineNum":"  235","line":"            const default_typed: *const field.type = @ptrCast(@alignCast(default_ptr));"},
{"lineNum":"  236","line":"            @field(result, field.name) = default_typed.*;"},
{"lineNum":"  237","line":"        } else {"},
{"lineNum":"  238","line":"            @compileError(\"Missing field in nested override: \" ++ field.name);"},
{"lineNum":"  239","line":"        }"},
{"lineNum":"  240","line":"    }"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"    return result;"},
{"lineNum":"  243","line":"}"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"/// Build a typed value from an anonymous source value (recursive for nested structs)"},
{"lineNum":"  246","line":"fn buildTypedPayload(comptime TargetType: type, source: anytype) TargetType {"},
{"lineNum":"  247","line":"    const SourceType = @TypeOf(source);"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"    // If already the right type, return directly"},
{"lineNum":"  250","line":"    if (SourceType == TargetType) {"},
{"lineNum":"  251","line":"        return source;"},
{"lineNum":"  252","line":"    }"},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"    // If both are structs, copy fields (with support for default values and recursive coercion)"},
{"lineNum":"  255","line":"    if (@typeInfo(TargetType) == .@\"struct\" and @typeInfo(SourceType) == .@\"struct\") {"},
{"lineNum":"  256","line":"        var result: TargetType = undefined;"},
{"lineNum":"  257","line":"        inline for (std.meta.fields(TargetType)) |field| {"},
{"lineNum":"  258","line":"            if (@hasField(SourceType, field.name)) {"},
{"lineNum":"  259","line":"                const source_value = @field(source, field.name);"},
{"lineNum":"  260","line":"                const SourceFieldType = @TypeOf(source_value);"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"                // If field types match, assign directly"},
{"lineNum":"  263","line":"                if (SourceFieldType == field.type) {"},
{"lineNum":"  264","line":"                    @field(result, field.name) = source_value;"},
{"lineNum":"  265","line":"                }"},
{"lineNum":"  266","line":"                // If both are structs but different types, recursively coerce"},
{"lineNum":"  267","line":"                else if (@typeInfo(field.type) == .@\"struct\" and @typeInfo(SourceFieldType) == .@\"struct\") {"},
{"lineNum":"  268","line":"                    @field(result, field.name) = buildTypedPayload(field.type, source_value);"},
{"lineNum":"  269","line":"                }"},
{"lineNum":"  270","line":"                // If target is union and source is struct, coerce to union"},
{"lineNum":"  271","line":"                else if (@typeInfo(field.type) == .@\"union\" and @typeInfo(SourceFieldType) == .@\"struct\") {"},
{"lineNum":"  272","line":"                    @field(result, field.name) = coerceToUnion(field.type, source_value);"},
{"lineNum":"  273","line":"                }"},
{"lineNum":"  274","line":"                // Otherwise try direct coercion"},
{"lineNum":"  275","line":"                else {"},
{"lineNum":"  276","line":"                    @field(result, field.name) = source_value;"},
{"lineNum":"  277","line":"                }"},
{"lineNum":"  278","line":"            } else if (field.default_value_ptr) |default_ptr| {"},
{"lineNum":"  279","line":"                // Use the field\'s default value if not provided"},
{"lineNum":"  280","line":"                const default_typed: *const field.type = @ptrCast(@alignCast(default_ptr));"},
{"lineNum":"  281","line":"                @field(result, field.name) = default_typed.*;"},
{"lineNum":"  282","line":"            } else {"},
{"lineNum":"  283","line":"                @compileError(\"Missing field \'\" ++ field.name ++ \"\' in struct (no default value)\");"},
{"lineNum":"  284","line":"            }"},
{"lineNum":"  285","line":"        }"},
{"lineNum":"  286","line":"        return result;"},
{"lineNum":"  287","line":"    }"},
{"lineNum":"  288","line":""},
{"lineNum":"  289","line":"    // For non-struct types, try direct coercion"},
{"lineNum":"  290","line":"    return source;"},
{"lineNum":"  291","line":"}"},
{"lineNum":"  292","line":""},
{"lineNum":"  293","line":"fn FactoryImpl(comptime T: type, comptime defaults: anytype, comptime depth: usize) type {"},
{"lineNum":"  294","line":"    if (depth > 3) {"},
{"lineNum":"  295","line":"        @compileError(\"Factory associations cannot be nested more than 3 levels deep\");"},
{"lineNum":"  296","line":"    }"},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":"    return struct {"},
{"lineNum":"  299","line":"        const Self = @This();"},
{"lineNum":"  300","line":"        pub const Target = T;"},
{"lineNum":"  301","line":"        pub const default_values = defaults;"},
{"lineNum":"  302","line":"        pub const nesting_depth = depth;"},
{"lineNum":"  303","line":""},
{"lineNum":"  304","line":"        /// Build an instance using std.testing.allocator"},
{"lineNum":"  305","line":"        pub fn build(overrides: anytype) T {","class":"lineCov","hits":"7","order":"58","possible_hits":"7",},
{"lineNum":"  306","line":"            return buildWith(std.testing.allocator, overrides);","class":"lineCov","hits":"19","order":"59","possible_hits":"19",},
{"lineNum":"  307","line":"        }"},
{"lineNum":"  308","line":""},
{"lineNum":"  309","line":"        /// Build a pointer instance using std.testing.allocator"},
{"lineNum":"  310","line":"        pub fn buildPtr(overrides: anytype) *T {","class":"lineCov","hits":"1","order":"148","possible_hits":"1",},
{"lineNum":"  311","line":"            return buildPtrWith(std.testing.allocator, overrides);","class":"lineCov","hits":"2","order":"149","possible_hits":"2",},
{"lineNum":"  312","line":"        }"},
{"lineNum":"  313","line":""},
{"lineNum":"  314","line":"        /// Build an instance using a custom allocator"},
{"lineNum":"  315","line":"        pub fn buildWith(alloc: std.mem.Allocator, overrides: anytype) T {","class":"lineCov","hits":"8","order":"60","possible_hits":"8",},
{"lineNum":"  316","line":"            return buildInternal(alloc, overrides);","class":"lineCov","hits":"22","order":"61","possible_hits":"22",},
{"lineNum":"  317","line":"        }"},
{"lineNum":"  318","line":""},
{"lineNum":"  319","line":"        /// Build a pointer instance using a custom allocator"},
{"lineNum":"  320","line":"        pub fn buildPtrWith(alloc: std.mem.Allocator, overrides: anytype) *T {","class":"lineCov","hits":"1","order":"150","possible_hits":"1",},
{"lineNum":"  321","line":"            const ptr = alloc.create(T) catch @panic(\"factory allocation failed\");","class":"linePartCov","hits":"2","order":"151","possible_hits":"3",},
{"lineNum":"  322","line":"            ptr.* = buildInternal(alloc, overrides);","class":"lineCov","hits":"1","order":"152","possible_hits":"1",},
{"lineNum":"  323","line":"            return ptr;","class":"lineCov","hits":"2","order":"153","possible_hits":"2",},
{"lineNum":"  324","line":"        }"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"        fn buildInternal(alloc: std.mem.Allocator, overrides: anytype) T {","class":"lineCov","hits":"9","order":"62","possible_hits":"9",},
{"lineNum":"  327","line":"            var result: T = undefined;","class":"lineCov","hits":"9","order":"63","possible_hits":"9",},
{"lineNum":"  328","line":"            const target_fields = std.meta.fields(T);"},
{"lineNum":"  329","line":""},
{"lineNum":"  330","line":"            inline for (target_fields) |field| {"},
{"lineNum":"  331","line":"                const field_name = field.name;","class":"lineCov","hits":"16","order":"64","possible_hits":"16",},
{"lineNum":"  332","line":"                @field(result, field_name) = resolveField(field.type, field_name, alloc, overrides);","class":"lineCov","hits":"16","order":"65","possible_hits":"16",},
{"lineNum":"  333","line":"            }","class":"lineCov","hits":"16","order":"72","possible_hits":"16",},
{"lineNum":"  334","line":""},
{"lineNum":"  335","line":"            return result;","class":"lineCov","hits":"25","order":"75","possible_hits":"25",},
{"lineNum":"  336","line":"        }"},
{"lineNum":"  337","line":""},
{"lineNum":"  338","line":"        fn resolveField(comptime FieldType: type, comptime field_name: []const u8, alloc: std.mem.Allocator, overrides: anytype) FieldType {"},
{"lineNum":"  339","line":"            const OverridesType = @TypeOf(overrides);"},
{"lineNum":"  340","line":""},
{"lineNum":"  341","line":"            // Check if field is overridden"},
{"lineNum":"  342","line":"            if (OverridesType != @TypeOf(.{})) {","class":"lineCov","hits":"2","order":"81","possible_hits":"2",},
{"lineNum":"  343","line":"                if (@hasField(OverridesType, field_name)) {","class":"lineCov","hits":"2","order":"82","possible_hits":"2",},
{"lineNum":"  344","line":"                    const override_value = @field(overrides, field_name);","class":"lineCov","hits":"1","order":"83","possible_hits":"1",},
{"lineNum":"  345","line":"                    return processOverride(FieldType, override_value, alloc);","class":"lineCov","hits":"4","order":"84","possible_hits":"4",},
{"lineNum":"  346","line":"                }"},
{"lineNum":"  347","line":"            }"},
{"lineNum":"  348","line":""},
{"lineNum":"  349","line":"            // Use default value"},
{"lineNum":"  350","line":"            if (@hasField(@TypeOf(defaults), field_name)) {","class":"lineCov","hits":"14","order":"67","possible_hits":"14",},
{"lineNum":"  351","line":"                const default_value = @field(defaults, field_name);","class":"lineCov","hits":"8","order":"68","possible_hits":"8",},
{"lineNum":"  352","line":"                return resolveDefaultWithField(FieldType, field_name, default_value, alloc);","class":"lineCov","hits":"28","order":"69","possible_hits":"28",},
{"lineNum":"  353","line":"            }"},
{"lineNum":"  354","line":""},
{"lineNum":"  355","line":"            // Handle optional pointer - default to null"},
{"lineNum":"  356","line":"            if (comptime isOptionalPointer(FieldType)) {"},
{"lineNum":"  357","line":"                return null;"},
{"lineNum":"  358","line":"            }"},
{"lineNum":"  359","line":""},
{"lineNum":"  360","line":"            @compileError(\"No default value provided for field: \" ++ field_name);"},
{"lineNum":"  361","line":"        }"},
{"lineNum":"  362","line":""},
{"lineNum":"  363","line":"        fn processOverride(comptime FieldType: type, override_value: anytype, alloc: std.mem.Allocator) FieldType {"},
{"lineNum":"  364","line":"            const OverrideType = @TypeOf(override_value);"},
{"lineNum":"  365","line":""},
{"lineNum":"  366","line":"            // Direct value assignment"},
{"lineNum":"  367","line":"            if (OverrideType == FieldType) {"},
{"lineNum":"  368","line":"                return override_value;"},
{"lineNum":"  369","line":"            }"},
{"lineNum":"  370","line":""},
{"lineNum":"  371","line":"            // Handle anonymous struct to union coercion"},
{"lineNum":"  372","line":"            if (@typeInfo(FieldType) == .@\"union\" and @typeInfo(OverrideType) == .@\"struct\") {"},
{"lineNum":"  373","line":"                return coerceToUnion(FieldType, override_value);"},
{"lineNum":"  374","line":"            }"},
{"lineNum":"  375","line":""},
{"lineNum":"  376","line":"            // Handle struct overrides for nested types (pointer-to-struct)"},
{"lineNum":"  377","line":"            if (@typeInfo(OverrideType) == .@\"struct\" and @typeInfo(FieldType) == .pointer) {"},
{"lineNum":"  378","line":"                const ChildType = @typeInfo(FieldType).pointer.child;"},
{"lineNum":"  379","line":"                if (@typeInfo(ChildType) == .@\"struct\") {"},
{"lineNum":"  380","line":"                    const ptr = alloc.create(ChildType) catch @panic(\"factory allocation failed\");"},
{"lineNum":"  381","line":"                    ptr.* = buildNestedStruct(ChildType, override_value);"},
{"lineNum":"  382","line":"                    return ptr;"},
{"lineNum":"  383","line":"                }"},
{"lineNum":"  384","line":"            }"},
{"lineNum":"  385","line":""},
{"lineNum":"  386","line":"            // Handle anonymous struct to named struct coercion"},
{"lineNum":"  387","line":"            // e.g., .build(.{ .tint = .{ .r = 255, ... } }) -> Color{ .r = 255, ... }"},
{"lineNum":"  388","line":"            if (@typeInfo(FieldType) == .@\"struct\" and @typeInfo(OverrideType) == .@\"struct\") {"},
{"lineNum":"  389","line":"                return buildTypedPayload(FieldType, override_value);"},
{"lineNum":"  390","line":"            }"},
{"lineNum":"  391","line":""},
{"lineNum":"  392","line":"            // Coerce compatible types"},
{"lineNum":"  393","line":"            return @as(FieldType, override_value);","class":"lineCov","hits":"4","order":"86","possible_hits":"4",},
{"lineNum":"  394","line":"        }"},
{"lineNum":"  395","line":""},
{"lineNum":"  396","line":"        fn computeFieldHash(comptime field_name: []const u8) usize {"},
{"lineNum":"  397","line":"            // Create a unique ID based on type name and field name"},
{"lineNum":"  398","line":"            var hash: usize = 0;"},
{"lineNum":"  399","line":"            for (@typeName(T)) |c| {"},
{"lineNum":"  400","line":"                hash = hash *% 31 +% c;"},
{"lineNum":"  401","line":"            }"},
{"lineNum":"  402","line":"            for (field_name) |c| {"},
{"lineNum":"  403","line":"                hash = hash *% 31 +% c;"},
{"lineNum":"  404","line":"            }"},
{"lineNum":"  405","line":"            return hash;"},
{"lineNum":"  406","line":"        }"},
{"lineNum":"  407","line":""},
{"lineNum":"  408","line":"        fn resolveDefaultWithField(comptime FieldType: type, comptime field_name: []const u8, default_value: anytype, alloc: std.mem.Allocator) FieldType {"},
{"lineNum":"  409","line":"            const DefaultType = @TypeOf(default_value);"},
{"lineNum":"  410","line":""},
{"lineNum":"  411","line":"            // Handle sequence markers"},
{"lineNum":"  412","line":"            if (@typeInfo(DefaultType) == .@\"struct\" and @hasDecl(DefaultType, \"is_sequence\")) {","class":"lineCov","hits":"2","order":"94","possible_hits":"2",},
{"lineNum":"  413","line":"                const seq_id = comptime computeFieldHash(field_name);","class":"lineCov","hits":"2","order":"95","possible_hits":"2",},
{"lineNum":"  414","line":"                const seq_num = getNextSequence(seq_id);","class":"lineCov","hits":"2","order":"96","possible_hits":"2",},
{"lineNum":"  415","line":"                return @as(FieldType, @intCast(seq_num));","class":"lineCov","hits":"4","order":"101","possible_hits":"4",},
{"lineNum":"  416","line":"            }"},
{"lineNum":"  417","line":""},
{"lineNum":"  418","line":"            // Handle sequence format markers"},
{"lineNum":"  419","line":"            if (@typeInfo(DefaultType) == .@\"struct\" and @hasDecl(DefaultType, \"is_sequence_fmt\")) {","class":"lineCov","hits":"1","order":"111","possible_hits":"1",},
{"lineNum":"  420","line":"                const seq_id = comptime computeFieldHash(field_name);","class":"lineCov","hits":"1","order":"112","possible_hits":"1",},
{"lineNum":"  421","line":"                const seq_num = getNextSequence(seq_id);","class":"lineCov","hits":"1","order":"113","possible_hits":"1",},
{"lineNum":"  422","line":"                return std.fmt.allocPrint(alloc, DefaultType.format_string, .{seq_num}) catch @panic(\"sequence format failed\");","class":"linePartCov","hits":"4","order":"114","possible_hits":"5",},
{"lineNum":"  423","line":"            }"},
{"lineNum":"  424","line":""},
{"lineNum":"  425","line":"            // Handle lazy markers"},
{"lineNum":"  426","line":"            if (@typeInfo(DefaultType) == .@\"struct\" and @hasDecl(DefaultType, \"is_lazy\")) {","class":"lineCov","hits":"1","order":"165","possible_hits":"1",},
{"lineNum":"  427","line":"                return DefaultType.compute();","class":"lineCov","hits":"2","order":"166","possible_hits":"2",},
{"lineNum":"  428","line":"            }"},
{"lineNum":"  429","line":""},
{"lineNum":"  430","line":"            // Handle lazy alloc markers"},
{"lineNum":"  431","line":"            if (@typeInfo(DefaultType) == .@\"struct\" and @hasDecl(DefaultType, \"is_lazy_alloc\")) {"},
{"lineNum":"  432","line":"                return DefaultType.computeAlloc(alloc);"},
{"lineNum":"  433","line":"            }"},
{"lineNum":"  434","line":""},
{"lineNum":"  435","line":"            // Handle association markers"},
{"lineNum":"  436","line":"            if (@typeInfo(DefaultType) == .@\"struct\" and @hasDecl(DefaultType, \"is_assoc\")) {"},
{"lineNum":"  437","line":"                const AssocFactory = DefaultType.factory;"},
{"lineNum":"  438","line":"                return AssocFactory.buildPtrWith(alloc, .{});"},
{"lineNum":"  439","line":"            }"},
{"lineNum":"  440","line":""},
{"lineNum":"  441","line":"            // Handle null for optional pointers"},
{"lineNum":"  442","line":"            if (DefaultType == @TypeOf(null) and comptime isOptionalPointer(FieldType)) {","class":"lineCov","hits":"1","order":"158","possible_hits":"1",},
{"lineNum":"  443","line":"                return null;","class":"lineCov","hits":"2","order":"159","possible_hits":"2",},
{"lineNum":"  444","line":"            }"},
{"lineNum":"  445","line":""},
{"lineNum":"  446","line":"            // Direct value"},
{"lineNum":"  447","line":"            if (DefaultType == FieldType) {","class":"lineCov","hits":"2","order":"73","possible_hits":"2",},
{"lineNum":"  448","line":"                return default_value;","class":"lineCov","hits":"2","order":"74","possible_hits":"2",},
{"lineNum":"  449","line":"            }"},
{"lineNum":"  450","line":""},
{"lineNum":"  451","line":"            // Handle anonymous struct to union coercion"},
{"lineNum":"  452","line":"            // e.g., .{ .circle = .{ .radius = 10 } } -> Shape{ .circle = ... }"},
{"lineNum":"  453","line":"            if (@typeInfo(FieldType) == .@\"union\" and @typeInfo(DefaultType) == .@\"struct\") {"},
{"lineNum":"  454","line":"                return coerceToUnion(FieldType, default_value);"},
{"lineNum":"  455","line":"            }"},
{"lineNum":"  456","line":""},
{"lineNum":"  457","line":"            // Handle anonymous struct to named struct coercion"},
{"lineNum":"  458","line":"            // e.g., .{ .r = 255, .g = 255, .b = 255, .a = 255 } -> Color{ .r = 255, ... }"},
{"lineNum":"  459","line":"            if (@typeInfo(FieldType) == .@\"struct\" and @typeInfo(DefaultType) == .@\"struct\") {"},
{"lineNum":"  460","line":"                return buildTypedPayload(FieldType, default_value);"},
{"lineNum":"  461","line":"            }"},
{"lineNum":"  462","line":""},
{"lineNum":"  463","line":"            // Try coercion"},
{"lineNum":"  464","line":"            return @as(FieldType, default_value);","class":"lineCov","hits":"14","order":"71","possible_hits":"14",},
{"lineNum":"  465","line":"        }"},
{"lineNum":"  466","line":""},
{"lineNum":"  467","line":"        fn isOptionalPointer(comptime FieldType: type) bool {"},
{"lineNum":"  468","line":"            if (@typeInfo(FieldType) != .optional) return false;"},
{"lineNum":"  469","line":"            const child = @typeInfo(FieldType).optional.child;"},
{"lineNum":"  470","line":"            return @typeInfo(child) == .pointer;"},
{"lineNum":"  471","line":"        }"},
{"lineNum":"  472","line":""},
{"lineNum":"  473","line":"        /// Create a new factory with additional/overridden defaults (trait)"},
{"lineNum":"  474","line":"        pub fn trait(comptime trait_values: anytype) type {"},
{"lineNum":"  475","line":"            return TraitFactoryImpl(T, defaults, trait_values, depth);"},
{"lineNum":"  476","line":"        }"},
{"lineNum":"  477","line":"    };"},
{"lineNum":"  478","line":"}"},
{"lineNum":"  479","line":""},
{"lineNum":"  480","line":"/// Factory implementation for traits - stores both base defaults and trait overrides"},
{"lineNum":"  481","line":"fn TraitFactoryImpl(comptime T: type, comptime base_defaults: anytype, comptime trait_overrides: anytype, comptime depth: usize) type {"},
{"lineNum":"  482","line":"    if (depth > 3) {"},
{"lineNum":"  483","line":"        @compileError(\"Factory associations cannot be nested more than 3 levels deep\");"},
{"lineNum":"  484","line":"    }"},
{"lineNum":"  485","line":""},
{"lineNum":"  486","line":"    return struct {"},
{"lineNum":"  487","line":"        const Self = @This();"},
{"lineNum":"  488","line":"        pub const Target = T;"},
{"lineNum":"  489","line":"        pub const nesting_depth = depth;"},
{"lineNum":"  490","line":""},
{"lineNum":"  491","line":"        /// Build an instance using std.testing.allocator"},
{"lineNum":"  492","line":"        pub fn build(overrides: anytype) T {","class":"lineCov","hits":"1","order":"122","possible_hits":"1",},
{"lineNum":"  493","line":"            return buildWith(std.testing.allocator, overrides);","class":"lineCov","hits":"3","order":"123","possible_hits":"3",},
{"lineNum":"  494","line":"        }"},
{"lineNum":"  495","line":""},
{"lineNum":"  496","line":"        /// Build a pointer instance using std.testing.allocator"},
{"lineNum":"  497","line":"        pub fn buildPtr(overrides: anytype) *T {"},
{"lineNum":"  498","line":"            return buildPtrWith(std.testing.allocator, overrides);"},
{"lineNum":"  499","line":"        }"},
{"lineNum":"  500","line":""},
{"lineNum":"  501","line":"        /// Build an instance using a custom allocator"},
{"lineNum":"  502","line":"        pub fn buildWith(alloc: std.mem.Allocator, overrides: anytype) T {","class":"lineCov","hits":"1","order":"124","possible_hits":"1",},
{"lineNum":"  503","line":"            return buildInternal(alloc, overrides);","class":"lineCov","hits":"3","order":"125","possible_hits":"3",},
{"lineNum":"  504","line":"        }"},
{"lineNum":"  505","line":""},
{"lineNum":"  506","line":"        /// Build a pointer instance using a custom allocator"},
{"lineNum":"  507","line":"        pub fn buildPtrWith(alloc: std.mem.Allocator, overrides: anytype) *T {"},
{"lineNum":"  508","line":"            const ptr = alloc.create(T) catch @panic(\"factory allocation failed\");"},
{"lineNum":"  509","line":"            ptr.* = buildInternal(alloc, overrides);"},
{"lineNum":"  510","line":"            return ptr;"},
{"lineNum":"  511","line":"        }"},
{"lineNum":"  512","line":""},
{"lineNum":"  513","line":"        fn buildInternal(alloc: std.mem.Allocator, overrides: anytype) T {","class":"lineCov","hits":"1","order":"126","possible_hits":"1",},
{"lineNum":"  514","line":"            var result: T = undefined;","class":"lineCov","hits":"1","order":"127","possible_hits":"1",},
{"lineNum":"  515","line":"            const target_fields = std.meta.fields(T);"},
{"lineNum":"  516","line":""},
{"lineNum":"  517","line":"            inline for (target_fields) |field| {"},
{"lineNum":"  518","line":"                const field_name = field.name;","class":"lineCov","hits":"3","order":"128","possible_hits":"3",},
{"lineNum":"  519","line":"                @field(result, field_name) = resolveField(field.type, field_name, alloc, overrides);","class":"lineCov","hits":"3","order":"129","possible_hits":"3",},
{"lineNum":"  520","line":"            }","class":"lineCov","hits":"3","order":"136","possible_hits":"3",},
{"lineNum":"  521","line":""},
{"lineNum":"  522","line":"            return result;","class":"lineCov","hits":"3","order":"142","possible_hits":"3",},
{"lineNum":"  523","line":"        }"},
{"lineNum":"  524","line":""},
{"lineNum":"  525","line":"        fn resolveField(comptime FieldType: type, comptime field_name: []const u8, alloc: std.mem.Allocator, overrides: anytype) FieldType {"},
{"lineNum":"  526","line":"            const OverridesType = @TypeOf(overrides);"},
{"lineNum":"  527","line":""},
{"lineNum":"  528","line":"            // Check if field is overridden at call site"},
{"lineNum":"  529","line":"            if (OverridesType != @TypeOf(.{})) {"},
{"lineNum":"  530","line":"                if (@hasField(OverridesType, field_name)) {"},
{"lineNum":"  531","line":"                    const override_value = @field(overrides, field_name);"},
{"lineNum":"  532","line":"                    return processOverride(FieldType, override_value, alloc);"},
{"lineNum":"  533","line":"                }"},
{"lineNum":"  534","line":"            }"},
{"lineNum":"  535","line":""},
{"lineNum":"  536","line":"            // Check if field is in trait overrides"},
{"lineNum":"  537","line":"            if (@hasField(@TypeOf(trait_overrides), field_name)) {","class":"lineCov","hits":"1","order":"137","possible_hits":"1",},
{"lineNum":"  538","line":"                const trait_value = @field(trait_overrides, field_name);","class":"lineCov","hits":"1","order":"138","possible_hits":"1",},
{"lineNum":"  539","line":"                return resolveDefaultWithField(FieldType, field_name, trait_value, alloc);","class":"lineCov","hits":"2","order":"139","possible_hits":"2",},
{"lineNum":"  540","line":"            }"},
{"lineNum":"  541","line":""},
{"lineNum":"  542","line":"            // Use base default value"},
{"lineNum":"  543","line":"            if (@hasField(@TypeOf(base_defaults), field_name)) {","class":"lineCov","hits":"2","order":"131","possible_hits":"2",},
{"lineNum":"  544","line":"                const default_value = @field(base_defaults, field_name);","class":"lineCov","hits":"2","order":"132","possible_hits":"2",},
{"lineNum":"  545","line":"                return resolveDefaultWithField(FieldType, field_name, default_value, alloc);","class":"lineCov","hits":"4","order":"133","possible_hits":"4",},
{"lineNum":"  546","line":"            }"},
{"lineNum":"  547","line":""},
{"lineNum":"  548","line":"            // Handle optional pointer - default to null"},
{"lineNum":"  549","line":"            if (comptime isOptionalPointer(FieldType)) {"},
{"lineNum":"  550","line":"                return null;"},
{"lineNum":"  551","line":"            }"},
{"lineNum":"  552","line":""},
{"lineNum":"  553","line":"            @compileError(\"No default value provided for field: \" ++ field_name);"},
{"lineNum":"  554","line":"        }"},
{"lineNum":"  555","line":""},
{"lineNum":"  556","line":"        fn processOverride(comptime FieldType: type, override_value: anytype, alloc: std.mem.Allocator) FieldType {"},
{"lineNum":"  557","line":"            const OverrideType = @TypeOf(override_value);"},
{"lineNum":"  558","line":""},
{"lineNum":"  559","line":"            // Direct value assignment"},
{"lineNum":"  560","line":"            if (OverrideType == FieldType) {"},
{"lineNum":"  561","line":"                return override_value;"},
{"lineNum":"  562","line":"            }"},
{"lineNum":"  563","line":""},
{"lineNum":"  564","line":"            // Handle anonymous struct to union coercion"},
{"lineNum":"  565","line":"            if (@typeInfo(FieldType) == .@\"union\" and @typeInfo(OverrideType) == .@\"struct\") {"},
{"lineNum":"  566","line":"                return coerceToUnion(FieldType, override_value);"},
{"lineNum":"  567","line":"            }"},
{"lineNum":"  568","line":""},
{"lineNum":"  569","line":"            // Handle struct overrides for nested types (pointer-to-struct)"},
{"lineNum":"  570","line":"            if (@typeInfo(OverrideType) == .@\"struct\" and @typeInfo(FieldType) == .pointer) {"},
{"lineNum":"  571","line":"                const ChildType = @typeInfo(FieldType).pointer.child;"},
{"lineNum":"  572","line":"                if (@typeInfo(ChildType) == .@\"struct\") {"},
{"lineNum":"  573","line":"                    const ptr = alloc.create(ChildType) catch @panic(\"factory allocation failed\");"},
{"lineNum":"  574","line":"                    ptr.* = buildNestedStruct(ChildType, override_value);"},
{"lineNum":"  575","line":"                    return ptr;"},
{"lineNum":"  576","line":"                }"},
{"lineNum":"  577","line":"            }"},
{"lineNum":"  578","line":""},
{"lineNum":"  579","line":"            // Handle anonymous struct to named struct coercion"},
{"lineNum":"  580","line":"            // e.g., .build(.{ .tint = .{ .r = 255, ... } }) -> Color{ .r = 255, ... }"},
{"lineNum":"  581","line":"            if (@typeInfo(FieldType) == .@\"struct\" and @typeInfo(OverrideType) == .@\"struct\") {"},
{"lineNum":"  582","line":"                return buildTypedPayload(FieldType, override_value);"},
{"lineNum":"  583","line":"            }"},
{"lineNum":"  584","line":""},
{"lineNum":"  585","line":"            // Coerce compatible types"},
{"lineNum":"  586","line":"            return @as(FieldType, override_value);"},
{"lineNum":"  587","line":"        }"},
{"lineNum":"  588","line":""},
{"lineNum":"  589","line":"        fn computeFieldHash(comptime field_name: []const u8) usize {"},
{"lineNum":"  590","line":"            var hash: usize = 0;"},
{"lineNum":"  591","line":"            for (@typeName(T)) |c| {"},
{"lineNum":"  592","line":"                hash = hash *% 31 +% c;"},
{"lineNum":"  593","line":"            }"},
{"lineNum":"  594","line":"            for (field_name) |c| {"},
{"lineNum":"  595","line":"                hash = hash *% 31 +% c;"},
{"lineNum":"  596","line":"            }"},
{"lineNum":"  597","line":"            return hash;"},
{"lineNum":"  598","line":"        }"},
{"lineNum":"  599","line":""},
{"lineNum":"  600","line":"        fn resolveDefaultWithField(comptime FieldType: type, comptime field_name: []const u8, default_value: anytype, alloc: std.mem.Allocator) FieldType {"},
{"lineNum":"  601","line":"            const DefaultType = @TypeOf(default_value);"},
{"lineNum":"  602","line":""},
{"lineNum":"  603","line":"            // Handle sequence markers"},
{"lineNum":"  604","line":"            if (@typeInfo(DefaultType) == .@\"struct\" and @hasDecl(DefaultType, \"is_sequence\")) {"},
{"lineNum":"  605","line":"                const seq_id = comptime computeFieldHash(field_name);"},
{"lineNum":"  606","line":"                const seq_num = getNextSequence(seq_id);"},
{"lineNum":"  607","line":"                return @as(FieldType, @intCast(seq_num));"},
{"lineNum":"  608","line":"            }"},
{"lineNum":"  609","line":""},
{"lineNum":"  610","line":"            // Handle sequence format markers"},
{"lineNum":"  611","line":"            if (@typeInfo(DefaultType) == .@\"struct\" and @hasDecl(DefaultType, \"is_sequence_fmt\")) {"},
{"lineNum":"  612","line":"                const seq_id = comptime computeFieldHash(field_name);"},
{"lineNum":"  613","line":"                const seq_num = getNextSequence(seq_id);"},
{"lineNum":"  614","line":"                return std.fmt.allocPrint(alloc, DefaultType.format_string, .{seq_num}) catch @panic(\"sequence format failed\");"},
{"lineNum":"  615","line":"            }"},
{"lineNum":"  616","line":""},
{"lineNum":"  617","line":"            // Handle lazy markers"},
{"lineNum":"  618","line":"            if (@typeInfo(DefaultType) == .@\"struct\" and @hasDecl(DefaultType, \"is_lazy\")) {"},
{"lineNum":"  619","line":"                return DefaultType.compute();"},
{"lineNum":"  620","line":"            }"},
{"lineNum":"  621","line":""},
{"lineNum":"  622","line":"            // Handle lazy alloc markers"},
{"lineNum":"  623","line":"            if (@typeInfo(DefaultType) == .@\"struct\" and @hasDecl(DefaultType, \"is_lazy_alloc\")) {"},
{"lineNum":"  624","line":"                return DefaultType.computeAlloc(alloc);"},
{"lineNum":"  625","line":"            }"},
{"lineNum":"  626","line":""},
{"lineNum":"  627","line":"            // Handle association markers"},
{"lineNum":"  628","line":"            if (@typeInfo(DefaultType) == .@\"struct\" and @hasDecl(DefaultType, \"is_assoc\")) {"},
{"lineNum":"  629","line":"                const AssocFactory = DefaultType.factory;"},
{"lineNum":"  630","line":"                return AssocFactory.buildPtrWith(alloc, .{});"},
{"lineNum":"  631","line":"            }"},
{"lineNum":"  632","line":""},
{"lineNum":"  633","line":"            // Handle null for optional pointers"},
{"lineNum":"  634","line":"            if (DefaultType == @TypeOf(null) and comptime isOptionalPointer(FieldType)) {"},
{"lineNum":"  635","line":"                return null;"},
{"lineNum":"  636","line":"            }"},
{"lineNum":"  637","line":""},
{"lineNum":"  638","line":"            // Direct value"},
{"lineNum":"  639","line":"            if (DefaultType == FieldType) {","class":"lineCov","hits":"1","order":"140","possible_hits":"1",},
{"lineNum":"  640","line":"                return default_value;","class":"lineCov","hits":"1","order":"141","possible_hits":"1",},
{"lineNum":"  641","line":"            }"},
{"lineNum":"  642","line":""},
{"lineNum":"  643","line":"            // Handle anonymous struct to union coercion"},
{"lineNum":"  644","line":"            // e.g., .{ .circle = .{ .radius = 10 } } -> Shape{ .circle = ... }"},
{"lineNum":"  645","line":"            if (@typeInfo(FieldType) == .@\"union\" and @typeInfo(DefaultType) == .@\"struct\") {"},
{"lineNum":"  646","line":"                return coerceToUnion(FieldType, default_value);"},
{"lineNum":"  647","line":"            }"},
{"lineNum":"  648","line":""},
{"lineNum":"  649","line":"            // Handle anonymous struct to named struct coercion"},
{"lineNum":"  650","line":"            // e.g., .{ .r = 255, .g = 255, .b = 255, .a = 255 } -> Color{ .r = 255, ... }"},
{"lineNum":"  651","line":"            if (@typeInfo(FieldType) == .@\"struct\" and @typeInfo(DefaultType) == .@\"struct\") {"},
{"lineNum":"  652","line":"                return buildTypedPayload(FieldType, default_value);"},
{"lineNum":"  653","line":"            }"},
{"lineNum":"  654","line":""},
{"lineNum":"  655","line":"            // Try coercion"},
{"lineNum":"  656","line":"            return @as(FieldType, default_value);","class":"lineCov","hits":"4","order":"135","possible_hits":"4",},
{"lineNum":"  657","line":"        }"},
{"lineNum":"  658","line":""},
{"lineNum":"  659","line":"        fn isOptionalPointer(comptime FieldType: type) bool {"},
{"lineNum":"  660","line":"            if (@typeInfo(FieldType) != .optional) return false;"},
{"lineNum":"  661","line":"            const child = @typeInfo(FieldType).optional.child;"},
{"lineNum":"  662","line":"            return @typeInfo(child) == .pointer;"},
{"lineNum":"  663","line":"        }"},
{"lineNum":"  664","line":""},
{"lineNum":"  665","line":"        /// Create a new factory with additional/overridden defaults (trait)"},
{"lineNum":"  666","line":"        pub fn trait(comptime new_trait_values: anytype) type {"},
{"lineNum":"  667","line":"            // Chain traits by creating a new trait factory with combined overrides"},
{"lineNum":"  668","line":"            return TraitFactoryImpl(T, base_defaults, mergeTrait(trait_overrides, new_trait_values), depth);"},
{"lineNum":"  669","line":"        }"},
{"lineNum":"  670","line":""},
{"lineNum":"  671","line":"        fn mergeTrait(comptime base: anytype, comptime overlay: anytype) MergedTraitType(base, overlay) {"},
{"lineNum":"  672","line":"            const OverlayType = @TypeOf(overlay);"},
{"lineNum":"  673","line":"            var result: MergedTraitType(base, overlay) = undefined;"},
{"lineNum":"  674","line":"            // Only copy base fields that are NOT overridden by overlay (to avoid type mismatch)"},
{"lineNum":"  675","line":"            inline for (std.meta.fields(@TypeOf(base))) |field| {"},
{"lineNum":"  676","line":"                if (!@hasField(OverlayType, field.name)) {"},
{"lineNum":"  677","line":"                    @field(result, field.name) = @field(base, field.name);"},
{"lineNum":"  678","line":"                }"},
{"lineNum":"  679","line":"            }"},
{"lineNum":"  680","line":"            // Copy all overlay fields"},
{"lineNum":"  681","line":"            inline for (std.meta.fields(OverlayType)) |field| {"},
{"lineNum":"  682","line":"                @field(result, field.name) = @field(overlay, field.name);"},
{"lineNum":"  683","line":"            }"},
{"lineNum":"  684","line":"            return result;"},
{"lineNum":"  685","line":"        }"},
{"lineNum":"  686","line":""},
{"lineNum":"  687","line":"        fn MergedTraitType(comptime base: anytype, comptime overlay: anytype) type {"},
{"lineNum":"  688","line":"            const BaseType = @TypeOf(base);"},
{"lineNum":"  689","line":"            const OverlayType = @TypeOf(overlay);"},
{"lineNum":"  690","line":"            const base_fields = std.meta.fields(BaseType);"},
{"lineNum":"  691","line":"            const overlay_fields = std.meta.fields(OverlayType);"},
{"lineNum":"  692","line":""},
{"lineNum":"  693","line":"            var fields: [base_fields.len + overlay_fields.len]std.builtin.Type.StructField = undefined;"},
{"lineNum":"  694","line":"            var count: usize = 0;"},
{"lineNum":"  695","line":""},
{"lineNum":"  696","line":"            // Add base fields (that are not in overlay)"},
{"lineNum":"  697","line":"            inline for (base_fields) |field| {"},
{"lineNum":"  698","line":"                if (!@hasField(OverlayType, field.name)) {"},
{"lineNum":"  699","line":"                    fields[count] = field;"},
{"lineNum":"  700","line":"                    count += 1;"},
{"lineNum":"  701","line":"                }"},
{"lineNum":"  702","line":"            }"},
{"lineNum":"  703","line":""},
{"lineNum":"  704","line":"            // Add all overlay fields"},
{"lineNum":"  705","line":"            inline for (overlay_fields) |field| {"},
{"lineNum":"  706","line":"                fields[count] = field;"},
{"lineNum":"  707","line":"                count += 1;"},
{"lineNum":"  708","line":"            }"},
{"lineNum":"  709","line":""},
{"lineNum":"  710","line":"            return @Type(.{"},
{"lineNum":"  711","line":"                .@\"struct\" = .{"},
{"lineNum":"  712","line":"                    .layout = .auto,"},
{"lineNum":"  713","line":"                    .fields = fields[0..count],"},
{"lineNum":"  714","line":"                    .decls = &.{},"},
{"lineNum":"  715","line":"                    .is_tuple = false,"},
{"lineNum":"  716","line":"                },"},
{"lineNum":"  717","line":"            });"},
{"lineNum":"  718","line":"        }"},
{"lineNum":"  719","line":"    };"},
{"lineNum":"  720","line":"}"},
{"lineNum":"  721","line":""},
{"lineNum":"  722","line":"// Tests"},
{"lineNum":"  723","line":"test \"basic factory\" {","class":"lineCov","hits":"1","order":"56","possible_hits":"1",},
{"lineNum":"  724","line":"    const User = struct {"},
{"lineNum":"  725","line":"        name: []const u8,"},
{"lineNum":"  726","line":"        age: u8,"},
{"lineNum":"  727","line":"        active: bool,"},
{"lineNum":"  728","line":"    };"},
{"lineNum":"  729","line":""},
{"lineNum":"  730","line":"    const UserFactory = define(User, .{"},
{"lineNum":"  731","line":"        .name = \"John Doe\","},
{"lineNum":"  732","line":"        .age = 25,"},
{"lineNum":"  733","line":"        .active = true,"},
{"lineNum":"  734","line":"    });"},
{"lineNum":"  735","line":""},
{"lineNum":"  736","line":"    const user = UserFactory.build(.{});","class":"lineCov","hits":"1","order":"57","possible_hits":"1",},
{"lineNum":"  737","line":"    try std.testing.expectEqualStrings(\"John Doe\", user.name);","class":"linePartCov","hits":"2","order":"76","possible_hits":"3",},
{"lineNum":"  738","line":"    try std.testing.expectEqual(@as(u8, 25), user.age);","class":"linePartCov","hits":"2","order":"77","possible_hits":"3",},
{"lineNum":"  739","line":"    try std.testing.expect(user.active);","class":"linePartCov","hits":"3","order":"78","possible_hits":"4",},
{"lineNum":"  740","line":"}"},
{"lineNum":"  741","line":""},
{"lineNum":"  742","line":"test \"factory with overrides\" {","class":"lineCov","hits":"1","order":"79","possible_hits":"1",},
{"lineNum":"  743","line":"    const User = struct {"},
{"lineNum":"  744","line":"        name: []const u8,"},
{"lineNum":"  745","line":"        age: u8,"},
{"lineNum":"  746","line":"    };"},
{"lineNum":"  747","line":""},
{"lineNum":"  748","line":"    const UserFactory = define(User, .{"},
{"lineNum":"  749","line":"        .name = \"John\","},
{"lineNum":"  750","line":"        .age = 25,"},
{"lineNum":"  751","line":"    });"},
{"lineNum":"  752","line":""},
{"lineNum":"  753","line":"    const user = UserFactory.build(.{ .name = \"Jane\", .age = 30 });","class":"lineCov","hits":"1","order":"80","possible_hits":"1",},
{"lineNum":"  754","line":"    try std.testing.expectEqualStrings(\"Jane\", user.name);","class":"linePartCov","hits":"2","order":"87","possible_hits":"3",},
{"lineNum":"  755","line":"    try std.testing.expectEqual(@as(u8, 30), user.age);","class":"linePartCov","hits":"3","order":"88","possible_hits":"4",},
{"lineNum":"  756","line":"}"},
{"lineNum":"  757","line":""},
{"lineNum":"  758","line":"test \"factory sequence\" {","class":"lineCov","hits":"1","order":"89","possible_hits":"1",},
{"lineNum":"  759","line":"    resetSequences();","class":"lineCov","hits":"1","order":"90","possible_hits":"1",},
{"lineNum":"  760","line":""},
{"lineNum":"  761","line":"    const User = struct {"},
{"lineNum":"  762","line":"        id: u32,"},
{"lineNum":"  763","line":"        name: []const u8,"},
{"lineNum":"  764","line":"    };"},
{"lineNum":"  765","line":""},
{"lineNum":"  766","line":"    const UserFactory = define(User, .{"},
{"lineNum":"  767","line":"        .id = sequence(u32),"},
{"lineNum":"  768","line":"        .name = \"User\","},
{"lineNum":"  769","line":"    });"},
{"lineNum":"  770","line":""},
{"lineNum":"  771","line":"    const user1 = UserFactory.build(.{});","class":"lineCov","hits":"1","order":"93","possible_hits":"1",},
{"lineNum":"  772","line":"    const user2 = UserFactory.build(.{});","class":"lineCov","hits":"1","order":"102","possible_hits":"1",},
{"lineNum":"  773","line":"    const user3 = UserFactory.build(.{});","class":"lineCov","hits":"1","order":"103","possible_hits":"1",},
{"lineNum":"  774","line":""},
{"lineNum":"  775","line":"    try std.testing.expectEqual(@as(u32, 1), user1.id);","class":"linePartCov","hits":"2","order":"104","possible_hits":"3",},
{"lineNum":"  776","line":"    try std.testing.expectEqual(@as(u32, 2), user2.id);","class":"linePartCov","hits":"2","order":"105","possible_hits":"3",},
{"lineNum":"  777","line":"    try std.testing.expectEqual(@as(u32, 3), user3.id);","class":"linePartCov","hits":"3","order":"106","possible_hits":"4",},
{"lineNum":"  778","line":"}"},
{"lineNum":"  779","line":""},
{"lineNum":"  780","line":"test \"factory sequenceFmt\" {","class":"lineCov","hits":"1","order":"107","possible_hits":"1",},
{"lineNum":"  781","line":"    resetSequences();","class":"lineCov","hits":"1","order":"108","possible_hits":"1",},
{"lineNum":"  782","line":""},
{"lineNum":"  783","line":"    const User = struct {"},
{"lineNum":"  784","line":"        email: []const u8,"},
{"lineNum":"  785","line":"    };"},
{"lineNum":"  786","line":""},
{"lineNum":"  787","line":"    const UserFactory = define(User, .{"},
{"lineNum":"  788","line":"        .email = sequenceFmt(\"user{d}@example.com\"),"},
{"lineNum":"  789","line":"    });"},
{"lineNum":"  790","line":""},
{"lineNum":"  791","line":"    // Use arena allocator since sequenceFmt allocates strings"},
{"lineNum":"  792","line":"    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);","class":"lineCov","hits":"1","order":"109","possible_hits":"1",},
{"lineNum":"  793","line":"    defer arena.deinit();","class":"linePartCov","hits":"3","order":"118","possible_hits":"7",},
{"lineNum":"  794","line":""},
{"lineNum":"  795","line":"    const user1 = UserFactory.buildWith(arena.allocator(), .{});","class":"lineCov","hits":"2","order":"110","possible_hits":"2",},
{"lineNum":"  796","line":"    const user2 = UserFactory.buildWith(arena.allocator(), .{});","class":"lineCov","hits":"2","order":"115","possible_hits":"2",},
{"lineNum":"  797","line":""},
{"lineNum":"  798","line":"    try std.testing.expectEqualStrings(\"user1@example.com\", user1.email);","class":"linePartCov","hits":"2","order":"116","possible_hits":"3",},
{"lineNum":"  799","line":"    try std.testing.expectEqualStrings(\"user2@example.com\", user2.email);","class":"linePartCov","hits":"2","order":"117","possible_hits":"3",},
{"lineNum":"  800","line":"}"},
{"lineNum":"  801","line":""},
{"lineNum":"  802","line":"test \"factory trait\" {","class":"lineCov","hits":"1","order":"119","possible_hits":"1",},
{"lineNum":"  803","line":"    const User = struct {"},
{"lineNum":"  804","line":"        name: []const u8,"},
{"lineNum":"  805","line":"        role: []const u8,"},
{"lineNum":"  806","line":"        active: bool,"},
{"lineNum":"  807","line":"    };"},
{"lineNum":"  808","line":""},
{"lineNum":"  809","line":"    const UserFactory = define(User, .{"},
{"lineNum":"  810","line":"        .name = \"John\","},
{"lineNum":"  811","line":"        .role = \"user\","},
{"lineNum":"  812","line":"        .active = true,"},
{"lineNum":"  813","line":"    });"},
{"lineNum":"  814","line":""},
{"lineNum":"  815","line":"    const AdminFactory = UserFactory.trait(.{"},
{"lineNum":"  816","line":"        .role = \"admin\","},
{"lineNum":"  817","line":"    });"},
{"lineNum":"  818","line":""},
{"lineNum":"  819","line":"    const user = UserFactory.build(.{});","class":"lineCov","hits":"1","order":"120","possible_hits":"1",},
{"lineNum":"  820","line":"    const admin = AdminFactory.build(.{});","class":"lineCov","hits":"1","order":"121","possible_hits":"1",},
{"lineNum":"  821","line":""},
{"lineNum":"  822","line":"    try std.testing.expectEqualStrings(\"user\", user.role);","class":"linePartCov","hits":"2","order":"143","possible_hits":"3",},
{"lineNum":"  823","line":"    try std.testing.expectEqualStrings(\"admin\", admin.role);","class":"linePartCov","hits":"2","order":"144","possible_hits":"3",},
{"lineNum":"  824","line":"    try std.testing.expectEqualStrings(\"John\", admin.name); // inherited","class":"linePartCov","hits":"3","order":"145","possible_hits":"4",},
{"lineNum":"  825","line":"}"},
{"lineNum":"  826","line":""},
{"lineNum":"  827","line":"test \"factory buildPtr\" {","class":"lineCov","hits":"1","order":"146","possible_hits":"1",},
{"lineNum":"  828","line":"    const User = struct {"},
{"lineNum":"  829","line":"        name: []const u8,"},
{"lineNum":"  830","line":"    };"},
{"lineNum":"  831","line":""},
{"lineNum":"  832","line":"    const UserFactory = define(User, .{"},
{"lineNum":"  833","line":"        .name = \"John\","},
{"lineNum":"  834","line":"    });"},
{"lineNum":"  835","line":""},
{"lineNum":"  836","line":"    const user_ptr = UserFactory.buildPtr(.{});","class":"lineCov","hits":"1","order":"147","possible_hits":"1",},
{"lineNum":"  837","line":"    defer std.testing.allocator.destroy(user_ptr);","class":"linePartCov","hits":"2","order":"155","possible_hits":"3",},
{"lineNum":"  838","line":""},
{"lineNum":"  839","line":"    try std.testing.expectEqualStrings(\"John\", user_ptr.name);","class":"linePartCov","hits":"2","order":"154","possible_hits":"3",},
{"lineNum":"  840","line":"}"},
{"lineNum":"  841","line":""},
{"lineNum":"  842","line":"test \"factory optional pointer defaults to null\" {","class":"lineCov","hits":"1","order":"156","possible_hits":"1",},
{"lineNum":"  843","line":"    const Company = struct {"},
{"lineNum":"  844","line":"        name: []const u8,"},
{"lineNum":"  845","line":"    };"},
{"lineNum":"  846","line":""},
{"lineNum":"  847","line":"    const User = struct {"},
{"lineNum":"  848","line":"        name: []const u8,"},
{"lineNum":"  849","line":"        company: ?*Company,"},
{"lineNum":"  850","line":"    };"},
{"lineNum":"  851","line":""},
{"lineNum":"  852","line":"    const UserFactory = define(User, .{"},
{"lineNum":"  853","line":"        .name = \"John\","},
{"lineNum":"  854","line":"        .company = null,"},
{"lineNum":"  855","line":"    });"},
{"lineNum":"  856","line":""},
{"lineNum":"  857","line":"    const user = UserFactory.build(.{});","class":"lineCov","hits":"1","order":"157","possible_hits":"1",},
{"lineNum":"  858","line":"    try std.testing.expectEqualStrings(\"John\", user.name);","class":"linePartCov","hits":"2","order":"160","possible_hits":"3",},
{"lineNum":"  859","line":"    try std.testing.expect(user.company == null);","class":"linePartCov","hits":"3","order":"161","possible_hits":"4",},
{"lineNum":"  860","line":"}"},
{"lineNum":"  861","line":""},
{"lineNum":"  862","line":"test \"factory lazy value\" {","class":"lineCov","hits":"1","order":"162","possible_hits":"1",},
{"lineNum":"  863","line":"    var counter: u32 = 0;","class":"lineCov","hits":"1","order":"163","possible_hits":"1",},
{"lineNum":"  864","line":""},
{"lineNum":"  865","line":"    const Item = struct {"},
{"lineNum":"  866","line":"        value: u32,"},
{"lineNum":"  867","line":"    };"},
{"lineNum":"  868","line":""},
{"lineNum":"  869","line":"    const getCounter = struct {"},
{"lineNum":"  870","line":"        fn get() u32 {","class":"lineCov","hits":"1","order":"167","possible_hits":"1",},
{"lineNum":"  871","line":"            return 42;","class":"lineCov","hits":"2","order":"168","possible_hits":"2",},
{"lineNum":"  872","line":"        }"},
{"lineNum":"  873","line":"    }.get;"},
{"lineNum":"  874","line":""},
{"lineNum":"  875","line":"    const ItemFactory = define(Item, .{"},
{"lineNum":"  876","line":"        .value = lazy(getCounter),"},
{"lineNum":"  877","line":"    });"},
{"lineNum":"  878","line":""},
{"lineNum":"  879","line":"    _ = &counter;"},
{"lineNum":"  880","line":""},
{"lineNum":"  881","line":"    const item = ItemFactory.build(.{});","class":"lineCov","hits":"1","order":"164","possible_hits":"1",},
{"lineNum":"  882","line":"    try std.testing.expectEqual(@as(u32, 42), item.value);","class":"linePartCov","hits":"3","order":"169","possible_hits":"4",},
{"lineNum":"  883","line":"}"},
{"lineNum":"  884","line":""},
{"lineNum":"  885","line":"test \"resetSequences resets counters\" {","class":"lineCov","hits":"1","order":"170","possible_hits":"1",},
{"lineNum":"  886","line":"    resetSequences();","class":"lineCov","hits":"1","order":"171","possible_hits":"1",},
{"lineNum":"  887","line":""},
{"lineNum":"  888","line":"    const Item = struct {"},
{"lineNum":"  889","line":"        id: u32,"},
{"lineNum":"  890","line":"    };"},
{"lineNum":"  891","line":""},
{"lineNum":"  892","line":"    const ItemFactory = define(Item, .{"},
{"lineNum":"  893","line":"        .id = sequence(u32),"},
{"lineNum":"  894","line":"    });"},
{"lineNum":"  895","line":""},
{"lineNum":"  896","line":"    _ = ItemFactory.build(.{});","class":"lineCov","hits":"1","order":"172","possible_hits":"1",},
{"lineNum":"  897","line":"    _ = ItemFactory.build(.{});","class":"lineCov","hits":"1","order":"173","possible_hits":"1",},
{"lineNum":"  898","line":"    const before_reset = ItemFactory.build(.{});","class":"lineCov","hits":"1","order":"174","possible_hits":"1",},
{"lineNum":"  899","line":"    try std.testing.expectEqual(@as(u32, 3), before_reset.id);","class":"linePartCov","hits":"2","order":"175","possible_hits":"3",},
{"lineNum":"  900","line":""},
{"lineNum":"  901","line":"    resetSequences();","class":"lineCov","hits":"1","order":"176","possible_hits":"1",},
{"lineNum":"  902","line":""},
{"lineNum":"  903","line":"    const after_reset = ItemFactory.build(.{});","class":"lineCov","hits":"1","order":"177","possible_hits":"1",},
{"lineNum":"  904","line":"    try std.testing.expectEqual(@as(u32, 1), after_reset.id);","class":"linePartCov","hits":"3","order":"178","possible_hits":"4",},
{"lineNum":"  905","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2025-12-23 20:25:51", "instrumented" : 118, "covered" : 118,};
var merged_data = [];
